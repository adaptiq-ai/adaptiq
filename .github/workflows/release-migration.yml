name: Release Migration

on:
  pull_request:
    types: [closed]
    branches: [main]

permissions:
  contents: write

jobs:
  migrate-to-release:
    if: github.event_name == 'pull_request' && github.event.action == 'closed' && github.event.pull_request.merged == true && github.event.pull_request.head.ref == 'pre-release'
    runs-on: ubuntu-latest
    outputs:
      release_version: ${{ steps.migrate.outputs.release_version }}
      pre_release_version: ${{ steps.migrate.outputs.pre_release_version }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install packaging toml

      - name: Configure Git
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

      - name: Switch to main branch
        run: |
          git fetch origin main
          git checkout main
          git reset --hard origin/main

      - name: Migrate version to release
        id: migrate
        run: |
          # Create Python script to handle version migration
          cat > version_migrate.py << 'EOF'
          import sys
          import re
          import os
          from datetime import datetime
          from packaging.version import Version

          def get_current_version():
              """Get current version from pyproject.toml or __init__.py"""
              try:
                  import tomllib
                  with open('pyproject.toml', 'rb') as f:
                      data = tomllib.load(f)
                      return data['project']['version']
              except:
                  try:
                      with open('src/adaptiq/__init__.py', 'r') as f:
                          content = f.read()
                          match = re.search(r'__version__\s*=\s*["\']([^"\']+)["\']', content)
                          if match:
                              return match.group(1)
                  except:
                      pass
                  return "0.0.0"

          def migrate_dev_to_release(dev_version):
              """Convert dev version to release version by removing .devXXXXXXXXXX"""
              if '.dev' in dev_version:
                  return dev_version.split('.dev')[0]
              return dev_version

          def update_version_in_files(new_version):
              """Update version in pyproject.toml and __init__.py"""
              # Update pyproject.toml
              with open('pyproject.toml', 'r') as f:
                  content = f.read()
              content = re.sub(r'version\s*=\s*["\'][^"\']+["\']', f'version = "{new_version}"', content)
              with open('pyproject.toml', 'w') as f:
                  f.write(content)

              # Update __init__.py
              init_file = 'src/adaptiq/__init__.py'
              try:
                  with open(init_file, 'r') as f:
                      content = f.read()
                  content = re.sub(r'__version__\s*=\s*["\'][^"\']+["\']', f'__version__ = "{new_version}"', content)
              except FileNotFoundError:
                  os.makedirs(os.path.dirname(init_file), exist_ok=True)
                  content = f'__version__ = "{new_version}"\n'

              with open(init_file, 'w') as f:
                  f.write(content)

          if __name__ == "__main__":
              current_version = get_current_version()
              release_version = migrate_dev_to_release(current_version)

              print(f"PRE_RELEASE_VERSION={current_version}")
              print(f"RELEASE_VERSION={release_version}")
              
              # Only update if there's actually a change
              if current_version != release_version:
                  update_version_in_files(release_version)
                  print("VERSION_UPDATED=true")
              else:
                  print("VERSION_UPDATED=false")
          EOF
                    
          # Run the version migration script
          python version_migrate.py > version_output.txt
          
          # Extract values from output
          PRE_RELEASE_VERSION=$(grep "PRE_RELEASE_VERSION=" version_output.txt | cut -d'=' -f2)
          RELEASE_VERSION=$(grep "RELEASE_VERSION=" version_output.txt | cut -d'=' -f2)
          VERSION_UPDATED=$(grep "VERSION_UPDATED=" version_output.txt | cut -d'=' -f2)
          
          echo "pre_release_version=$PRE_RELEASE_VERSION" >> $GITHUB_OUTPUT
          echo "release_version=$RELEASE_VERSION" >> $GITHUB_OUTPUT
          echo "version_updated=$VERSION_UPDATED" >> $GITHUB_OUTPUT
          
          # Clean up
          rm version_migrate.py version_output.txt

      - name: Commit version changes
        if: steps.migrate.outputs.version_updated == 'true'
        run: |
          RELEASE_VERSION="${{ steps.migrate.outputs.release_version }}"
          PRE_RELEASE_VERSION="${{ steps.migrate.outputs.pre_release_version }}"
          
          git add pyproject.toml src/adaptiq/__init__.py
          git commit -m "Release version: $PRE_RELEASE_VERSION â†’ $RELEASE_VERSION"
          
          # Create and push release tag
          git tag -a "v$RELEASE_VERSION" -m "Release $RELEASE_VERSION"

      - name: Update CHANGELOG.md
        run: |
          RELEASE_VERSION="${{ steps.migrate.outputs.release_version }}"
          DATE=$(date '+%Y-%m-%d')
          
          if [ -f "CHANGELOG.md" ]; then
            # Create temp file with new release entry
            cat > temp_changelog.md << EOF
          # Changelog

          ## [v$RELEASE_VERSION] - $DATE

          ### Released
          - Migrated from pre-release v${{ steps.migrate.outputs.pre_release_version }}
          - Merged PR #${{ github.event.pull_request.number }}: ${{ github.event.pull_request.title }}

          EOF

            # Append existing content (skip first line if it's just "# Changelog")
            if head -n 1 CHANGELOG.md | grep -q "^# Changelog$"; then
              tail -n +2 CHANGELOG.md >> temp_changelog.md
            else
              cat CHANGELOG.md >> temp_changelog.md
            fi
            mv temp_changelog.md CHANGELOG.md
          else
            cat > CHANGELOG.md << EOF
          # Changelog

          ## [v$RELEASE_VERSION] - $DATE

          ### Released
          - Migrated from pre-release v${{ steps.migrate.outputs.pre_release_version }}
          - Merged PR #${{ github.event.pull_request.number }}: ${{ github.event.pull_request.title }}

          EOF
          fi

          git add CHANGELOG.md
          git commit -m "Update CHANGELOG.md for release v$RELEASE_VERSION"

      - name: Push release changes and tags
        run: |
          git push origin main
          git push origin --tags

      - name: Build package
        id: build-package
        run: |
          python -m pip install --upgrade build
          python -m build

      # - name: Publish to PyPI
      #   id: publish-pypi
      #   uses: pypa/gh-action-pypi-publish@release/v1
      #   with:
      #     password: ${{ secrets.PYPI_API_TOKEN }}
      #     verbose: true

      - name: Create GitHub Release
        id: create-release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: v${{ steps.migrate.outputs.release_version }}
          release_name: Release v${{ steps.migrate.outputs.release_version }}
          body: |
            ## Release v${{ steps.migrate.outputs.release_version }}
            
            This release was automatically created from pre-release v${{ steps.migrate.outputs.pre_release_version }}.
            
            ### Changes
            - Migrated from pre-release branch
            - Merged PR #${{ github.event.pull_request.number }}: ${{ github.event.pull_request.title }}
            
            ### Installation
            ```bash
            pip install adaptiq==${{ steps.migrate.outputs.release_version }}
            ```
          draft: false
          prerelease: false

      # - name: Upload Release Assets
      #   uses: actions/upload-release-asset@v1
      #   env:
      #     GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      #   with:
      #     upload_url: ${{ steps.create-release.outputs.upload_url }}
      #     asset_path: ./dist/
      #     asset_name: distribution-files
      #     asset_content_type: application/zip

      - name: Rollback on failure
        if: failure()
        run: |
          echo "Release process failed. Rolling back changes..."
          
          # Get the version that was just created
          RELEASE_VERSION="${{ steps.migrate.outputs.release_version }}"
          
          # Delete the tag locally and remotely
          if [ -n "$RELEASE_VERSION" ]; then
            git tag -d "v$RELEASE_VERSION" || echo "Local tag not found"
            git push origin --delete "v$RELEASE_VERSION" || echo "Remote tag not found"
          fi
          
          # Reset main branch to previous commit (accounting for both version and changelog commits)
          git reset --hard HEAD~2
          git push origin main --force
          
          echo "Rollback completed. Release has been reverted."
          
          # Exit with failure to mark the workflow as failed
          exit 1

  notify-success:
    needs: migrate-to-release
    runs-on: ubuntu-latest
    if: success()
    steps:
      - name: Notify Success
        run: |
          echo "ðŸŽ‰ Successfully released version ${{ needs.migrate-to-release.outputs.release_version }}"
          # echo "ðŸ“¦ Package published to PyPI"
          # echo "ðŸ·ï¸ GitHub release created"
          echo "ðŸ“‹ CHANGELOG.md updated"